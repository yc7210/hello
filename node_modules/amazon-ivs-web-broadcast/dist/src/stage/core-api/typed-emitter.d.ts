export declare type EventMap = {
    [key: string]: Callback;
};
declare type Callback = (...args: any[]) => void;
/**
 * A typed event emitter.
 *
 * To use simply declare your events then create your emitter with a generic type:
 * ```typescript
 * type MyEvents = {
 *   foo: (bar: string) => void;
 * }
 *
 * const emitter = new TypedEmitter<MyEvents>();
 *
 * emitter.emit('foo', 'bar') // <- This is valid
 *
 * emitter.emit('foo', false) // <- This is a type error
 * emitter.emit('bar', 'baz') // <- This is also a type error
 * ```
 */
export declare class TypedEmitter<Events extends EventMap> {
    private emitter;
    /**
     * Creates a new TypedEmitter
     */
    constructor();
    /**
     * Register a new callback for event E
     *
     * @param event - the event to register the callback for
     * @param callback - the callback to be invoked for the event
     */
    on<E extends keyof Events>(event: E, callback: Events[E]): void;
    /**
     * De-register a callback for event E
     *
     * @param event - the event to de-register the callback for
     * @param callback - the callback to be de-registered
     */
    off<E extends keyof Events>(event: E, callback: Events[E]): void;
    /**
     * Emit args for event E
     *
     * @param event - the event name
     * @param ...args - the args for the event
     */
    emit<E extends keyof Events>(event: E, ...args: Parameters<Events[E]>): void;
    /**
     * Remove all event listeners
     */
    removeAllListeners(): void;
}
export {};
