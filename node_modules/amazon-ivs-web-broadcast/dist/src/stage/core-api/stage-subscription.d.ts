import { ConnectionState } from '../../client-common/broadcast-client-events';
import { Logger } from '../../client-common/logger';
import { BroadcastStageSubscriptionEventPayloads } from './stage-events';
import { TraceId } from './analytics/random.uuid';
import { StagePeerClient } from './peer-client';
import { Participant, StageConnection } from './stage-connection';
import { StageToken } from './token';
export declare enum SubscriptionConnectionState {
    INIT = "init",
    CONNECTING = "connecting",
    CONNECTED = "connected",
    UNSTABLE = "unstable",
    PAUSED = "paused",
    FAILED = "failed",
    STOPPED = "stopped"
}
export declare type SubscriptionState = {
    connectionState: SubscriptionConnectionState;
    subscribeInProgress: boolean;
};
/**
 * Encapsulates all the signals that are used to update
 * subscription state and attempt subscribes.
 */
declare type SignalState = {
    isTargetPublishing?: boolean;
    peerClientState?: ConnectionState;
};
export declare enum SubscribeType {
    /**
     * Do not subscribe to a participant.
     */
    NONE = "none",
    /**
     * Subscribe to participant's audio.
     */
    AUDIO_ONLY = "audio_only",
    /**
     * Subscribe to participant's audio and video.
     */
    AUDIO_VIDEO = "audio_video"
}
export declare class StageSubscription {
    #private;
    private id;
    private token;
    private stageConnection;
    private nonScopedLogger;
    private traceId;
    private emitter;
    private silentAudioTrack?;
    private analyticsTracker;
    private isSubscriptionActive;
    private subscriptionState;
    private peerClient;
    private previousSignalState;
    private failedRetries;
    private logger;
    private throttler;
    constructor(id: string, token: StageToken, stageConnection: StageConnection, nonScopedLogger: Logger, traceId: TraceId);
    /**
     * Either stop or start remote video according to subscriptionType
     *
     * @param subscriptionType - controls if we stop or start the video
     */
    updateSubscribeType: (subscriptionType: SubscribeType) => void;
    onParticipantUpdated: (participant: Participant) => void;
    onParticipantJoined: (participant: Participant) => void;
    onParticipantLeft: (participant: Participant) => void;
    /**
     * Once subscribed and a peer client exists, let's update subscription
     * state for disconnect and failed scenarios when reported by the peer client
     *
     * @param state - the state reported by peer client
     */
    onPeerClientConnectionStateChange(state: string): void;
    /**
     * Triggered whenever we get a signal update. Based on the update, handles changing subscription states
     * and/or attempting a subscribe.
     *
     * @param newState - Update with the change
     */
    onSignalStateChange(changedState: SignalState): void;
    /**
     * Move the state into FAILED and re-attempt a subscribe but not immediately
     * and after a wait period.  Wait period is based on how many times we've
     * failed previously.  After retry limit has been breached, recovery is
     * still possible if we get a new signal for isTargetPublishing=true.
     *
     * @param reason - Optional reason for the subscribe attempt
     */
    onAttemptSubscribeFailure(reason?: string): void;
    setCustomSilentAudioTrack(silentAudioTrack: MediaStreamTrack): void;
    /**
     * Activates a subscription. Callers should listen for CONNECTED event that
     * indicates subscription has connected.
     */
    start(): void;
    requestRTCStats: (track: MediaStreamTrack) => Promise<RTCStatsReport | undefined>;
    /**
     * Attempt to subscribe
     *
     * @param reason - The reason for the attempt.
     * @returns A boolean indicating if the attempt was successful.
     */
    attemptSubscribe: (reason?: string) => Promise<boolean>;
    throttledAttemptSubscribe(reason?: string): boolean;
    private changeState;
    /**
     * Registers (starts) a specified callback to a specified event.
     *
     * @param event - The event to listen to.
     * @param callback - The callback that will called when the event is fired.
     */
    on<Key extends keyof BroadcastStageSubscriptionEventPayloads & string>(event: Key, callback: (value: BroadcastStageSubscriptionEventPayloads[Key]) => void): void;
    /**
     * Deregisters (stops) a specified callback to a given event.
     *
     * @param event - The event to which the callback was registered.
     * @param callback - The callback to remove.
     */
    off<Key extends keyof BroadcastStageSubscriptionEventPayloads & string>(event: Key, callback: (value: BroadcastStageSubscriptionEventPayloads[Key]) => void): void;
    /**
     * Inactivates a subscription and cleans up
     */
    stop(): void;
    /**
     * Cleans up this subscription.
     */
    private cleanUp;
    /**
     * Get the active state of the subscription
     *
     * @returns active state of the subscription
     */
    isActive(): boolean;
    /**
     * Return the current StageSubscriptionState
     *
     * @returns The current StageSubscriptionState
     */
    getSubscriptionConnectionState(): SubscriptionConnectionState;
    subscribe(audioOnly?: boolean): Promise<{
        peerClient: StagePeerClient;
        mediaStream: MediaStream | null;
    }>;
    unsubscribe(): Promise<void>;
    private trackAndThrowUnsubscribeError;
    private trackSubscribeRequested;
    private trackSubscribeStarted;
    private trackSubscribeEnded;
}
export {};
