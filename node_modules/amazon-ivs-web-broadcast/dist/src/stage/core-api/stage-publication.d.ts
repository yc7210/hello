import { Logger } from '../../client-common/logger';
import { TraceId } from './analytics/random.uuid';
import { StagePeerClient } from './peer-client';
import { StageToken } from './token';
import { TypedEmitter } from './typed-emitter';
export declare enum StagePublicationState {
    DISCONNECTED = "disconnected",
    CONNECTING = "connecting",
    CONNECTED = "connected",
    ERRORED = "errored"
}
export declare enum StagePublicationEvents {
    STATE_CHANGE = "stateChange"
}
declare type PublicationEventMap = {
    [StagePublicationEvents.STATE_CHANGE]: (stage: StagePublicationState) => void;
};
export declare class StagePublication extends TypedEmitter<PublicationEventMap> {
    private token;
    private nonScopedLogger;
    private traceId;
    private peerClient;
    private analyticsTracker;
    tracksToPublish: [Maybe<MediaStreamTrack>, Maybe<MediaStreamTrack>];
    private logger;
    private publicationState;
    private latestPubAttemptNum;
    private isPublishing;
    private isStarted;
    constructor(token: StageToken, nonScopedLogger: Logger, traceId: TraceId, v2?: boolean);
    start: (tracks: [Maybe<MediaStreamTrack>, Maybe<MediaStreamTrack>]) => void;
    requestRTCStats: (track: MediaStreamTrack) => Promise<RTCStatsReport | undefined>;
    stop: () => Promise<void>;
    private processStateUpdate;
    private updateState;
    private tryPublish;
    publish: (tracks: [Maybe<MediaStreamTrack>, Maybe<MediaStreamTrack>]) => Promise<StagePeerClient>;
    unpublish: () => Promise<void>;
    removeTrack(trackType: string): Promise<void>;
    replaceTrack: (track: MediaStreamTrack) => Promise<void>;
    getAudioSender: () => RTCRtpSender | undefined;
    getVideoSender: () => RTCRtpSender | undefined;
    private onPeerClientConnectionStateChange;
    private trackPublishRequested;
    private trackPublishStarted;
    private trackPublishEnded;
}
export {};
