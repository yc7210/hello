import { Logger } from '../../client-common/logger';
import { BroadcastStageConnectionEvents } from './stage-events';
import { TraceId } from './analytics/random.uuid';
import { StageToken } from './token';
import { TypedEmitter } from './typed-emitter';
import { StagePeerClient } from './peer-client';
/**
 * Participant Type
 */
export declare type Participant = {
    isPublishing: boolean;
    id: string;
    attributes: Record<string, unknown>;
    audioMuted: boolean;
    joinedAt: number;
    mediaSrcObject: MediaStream;
    peerClient: StagePeerClient;
    userId: string;
    videoStopped: boolean;
    subscribed: boolean;
};
export interface StageStateMessage {
    payload: {
        participants?: Participant[];
        disconnected?: Participant[];
    };
}
export declare enum StageConnectionState {
    /**
     * SDK is not connected to Stage session
     */
    DISCONNECTED = "disconnected",
    /**
     * SDK is establishing connection to Stage session
     */
    CONNECTING = "connecting",
    /**
     * SDK is connected to Stage session
     */
    CONNECTED = "connected",
    /**
     * SDK errored in the middle of a session
     */
    ERRORED = "errored"
}
declare type ConnectionEventMap = {
    [BroadcastStageConnectionEvents.STATE_CHANGE]: (stage: StageConnectionState) => void;
    [BroadcastStageConnectionEvents.STAGE_JOINED]: () => void;
    [BroadcastStageConnectionEvents.STAGE_PARTICIPANT_JOINED]: (participant: Participant) => void;
    [BroadcastStageConnectionEvents.STAGE_PARTICIPANT_LEFT]: (participant: Participant) => void;
    [BroadcastStageConnectionEvents.STAGE_PARTICIPANT_KICKED]: (participant: Participant) => void;
    [BroadcastStageConnectionEvents.STAGE_PARTICIPANT_UPDATED]: (participant: Participant) => void;
    [BroadcastStageConnectionEvents.STAGE_REFRESH]: () => void;
};
export declare class StageConnection extends TypedEmitter<ConnectionEventMap> {
    private nonScopedLogger;
    private stageSocket;
    private participants;
    private disconnected;
    private analyticsTracker;
    private logger;
    private connectTimeout?;
    private state;
    constructor(nonScopedLogger: Logger);
    private onConnecting;
    private onConnected;
    private onDisconnected;
    private onErrored;
    private processStateUpdate;
    /**
     * Connect to the IVS Stage
     *
     * @param token - participant token for the Stage
     * @param traceId - traceId for the request
     * @returns Promise<void>
     */
    connect(token: StageToken, traceId: TraceId): Promise<void>;
    /**
     * Disconnect from the IVS Stage
     */
    disconnect(): TraceId | undefined;
    /**
     * Get a participant from the StageConnection
     *
     * @param id - the requested participant Id
     * @returns - the Participant object or undefined if not found
     */
    getParticipant(id: string): Participant | undefined;
    /**
     * Lists the participants the client is currently connected to.
     */
    listConnectedParticipants(): Array<Participant>;
    /**
     * Lists the all the Participants in the Stage.
     */
    listAvailableParticipants(): Array<Participant>;
    /**
     * Update the stage with the state of the local peer
     *
     * @param audioMuted - boolean.
     * @param videoStopped - boolean.
     */
    emitStageState(audioMuted: boolean, videoStopped: boolean): void;
    private trackConnectedEvent;
    private trackDisconnectedEvent;
    private trackMessageParseError;
    /**
     * This is a private function for handling Stage messages
     *
     * @param event - Message event to handle.
     */
    private onStageStateMessage;
}
export {};
