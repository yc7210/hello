import { type Config } from '../broadcast/configuration';
import type Worker from './scripts/scheduler.worker.ts';
export interface AudioDevice {
    name: string;
    source: MediaStream;
    audioTrackSource: MediaStreamAudioSourceNode;
    gainNode: GainNode;
}
export declare const mediaTracks: Map<"audio" | "video", Maybe<MediaStreamTrack>>;
/**
 * An interface to describe the position of a video device in the composite stream.
 */
export interface VideoComposition {
    /**
     * Z-index value. Devices with a higher index will be placed on top of devices with a lower index.
     */
    index: number;
    /**
     * Top-left x-coordinate of the device.
     */
    x?: number;
    /**
     * Top-left y-coordinate of the device.
     */
    y?: number;
    /**
     * Height of the device.
     */
    height?: number;
    /**
     * Width of the device.
     */
    width?: number;
}
export interface ImageDevice {
    /**
     * Unique name given to this device.
     */
    name: string;
    /**
     * CanvasImageSource for this device.
     */
    element: CanvasImageSource;
    /**
     * [[VideoComposition]] for this device.
     */
    position: VideoComposition;
    /**
     * Boolean to determine whether or not to render this source.
     */
    render: boolean;
}
/**
 * An interface to describe a video device.
 */
export interface VideoDevice {
    /**
     * Unique name given to this device.
     */
    name: string;
    /**
     * CanvasImageSource for this device.
     */
    element: CanvasImageSource;
    /**
     * [[VideoComposition]] for this device.
     */
    position: VideoComposition;
    /**
     * MediaStream or CanvasImageSource of this device.
     */
    source: MediaStream;
    /**
     * Boolean to determine whether or not to render this source
     */
    render: boolean;
}
/**
 * An interface to describe the dimensions of the HTML Canvas used to composite the stream.
 */
export interface CanvasDimensions {
    /**
     * Height of the canvas.
     */
    height: number;
    /**
     * Width of the canvas.
     */
    width: number;
}
export interface IMediaStreamManager {
    audioContext: AudioContext;
    start(): void;
    stop(): void;
    addVideoInputDevice(videoStream: MediaStream, name: string, position: VideoComposition): Promise<void>;
    addAudioInputDevice(audioStream: MediaStream, name: string): Promise<void>;
    addImageSource(image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap, name: string, position: VideoComposition): Promise<void>;
    getVideoInputDevice(name: string): Maybe<VideoDevice>;
    getAudioInputDevice(name: string): Maybe<MediaStream>;
    removeVideoInputDevice(name: string): void;
    removeAudioInputDevice(name: string): void;
    removeImage(name: string): void;
    enableVideo(): void;
    enableAudio(): void;
    disableVideo(): void;
    disableAudio(): void;
    getTracks(): [MapValueType<typeof mediaTracks>, MapValueType<typeof mediaTracks>];
    getAudioLatency(): number;
    getVideoLatency(): number;
    getCanvasDimensions(): CanvasDimensions;
    attachPreview(element: HTMLCanvasElement | HTMLVideoElement): void;
    detachPreview(): void;
    updateVideoDeviceComposition(name: string, composition: VideoComposition): void;
    exchangeVideoDevicePositions(name1: string, name2: string): void;
}
/**
 * This class is responsible for ensuring that we have a stable audio and video stream to broadcast over the WebRTC
 * PeerConnection. For ingesting into IVS we don't want to have audio and video tracks being added or removed mid-stream.
 * Adding and removing tracks is very common in WebRTC and that standard way to handle things like muting or
 * changing video inputs. So the MediaStreamManager acts as the adapter between these two worlds. Having this adapter
 * also gives us the ability support some different video operations, like compositing in the browser.
 *
 * The basic functionality is to take the input stream (audio or video) and pass it through some browser API that is
 * able to produce a new MediaStream. For audio this means we pass the microphone input to an AudioContext and for video
 * this means we pass the video input to a Canvas element. (For video you can't directly pass a MediaStreamTrack to a
 * canvas element. Instead we pass the MediaStreamTrack to a video element which can decode the video, and then we copy
 * the frame from the video element to the canvas element.) By passing the input streams through an intermediary browser
 * API in this way we introduce a seam where we are able to stop or remove an input track and the browser will continue
 * sending information from the browser API that is silent/blank.
 */
export declare class MediaStreamManager implements IMediaStreamManager {
    private config;
    private schedulerWorker;
    audioContext: AudioContext;
    compositeStream: MediaStream;
    private compositeEl;
    private compositeContext;
    private audioDestination;
    private running;
    private mixer;
    private previewElement;
    private previewCtx;
    private nextMix;
    private analyticsTracker;
    /**
     * Instantiates the [[MediaStreamManager]].
     *
     * @param config - [[Config]]
     * @param schedulerWorker - [[Worker]]
     */
    constructor(config: Config, schedulerWorker: Worker);
    /**
     * Attach a HTMLCanvasElement to display a preview of the output.
     *
     * @param element - An HTMLCanvasElement on which to draw the composited preview.
     */
    attachPreview(element: HTMLCanvasElement): void;
    /**
     * Detach the attached preview element.
     *
     */
    detachPreview(): void;
    /**
     * It creates a silent audio source that is connected to the audio context's
     * destination node.
     */
    setupSilence(): void;
    /**
     * If the audio context is suspended, then resume it and clean up the event listeners.
     */
    private unlockAudioContext;
    /**
     * Returns a tuple containing the available video track and audio track.
     */
    getTracks(): [MapValueType<typeof mediaTracks>, MapValueType<typeof mediaTracks>];
    /**
     * Returns the video track currently attached to the canvas.
     */
    getCanvasVideoTrack(): MapValueType<typeof mediaTracks>;
    /**
     * Looks through the mixer for an audio device associated with the provided name.
     *
     * @param name - Name of an audio input device.
     */
    getAudioInputDevice(name: string): Maybe<MediaStream>;
    /**
     * Looks through the mixer for a video device associated with the provided name.
     *
     * @param name - Name of a video input device.
     */
    getVideoInputDevice(name: string): Maybe<VideoDevice>;
    /**
     * Returns an object containing the broadcast canvas' height and width.
     */
    getCanvasDimensions(): CanvasDimensions;
    /**
     * Adds a provided video input to the mixer and composites it to the canvas stream.
     *
     * @param videoStream - A video stream of type [[MediaStream]] to add to the mixer.
     * @param name - A unique identifier to associate to the device.
     * @param position - The position to composite the device on the canvas.
     */
    addVideoInputDevice(videoStream: MediaStream, name: string, position: VideoComposition): Promise<void>;
    /**
     * Adds a provided image to the mixer and composites it to the canvas stream.
     *
     * @param image - An image to add to the mixer.
     * @param name - A unique identifier to associate to the device.
     * @param position - The position to composite the device on the canvas.
     */
    addImageSource(image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap, name: string, position: VideoComposition): Promise<void>;
    /**
     * Adds a provided audio input to the mixer and composites it to the canvas stream.
     *
     * @param audioStream - An audio stream to add to the mixer.
     * @param name - A unique identifier to associate to the device.
     */
    addAudioInputDevice(audioStream: MediaStream, name: string): Promise<void>;
    /**
     * Removes the specified image from the mixer and the composite stream.
     *
     * @param name - A unique identifier to associate to the device.
     */
    removeImage(name: string): void;
    /**
     * Removes the specified video device from the mixer and the composite stream.
     *
     * @param name - A unique identifier to associate to the device
     */
    removeVideoInputDevice(name: string): void;
    /**
     * Removes the specified audio device from the mixer and the composite stream.
     *
     * @param name - A unique identifier to associate to the device
     */
    removeAudioInputDevice(name: string): void;
    /**
     * Queries for the specified video device in the mixer and updates its composition properties.
     *
     * @param name - A reference to the video device to modify.
     * @param composition - A [[VideoComposition]] configuration with which to update the video device's composition in the mixer and canvas stream.
     */
    updateVideoDeviceComposition(name: string, composition: VideoComposition): void;
    /**
     * Takes 2 video devices and swaps their positions in the composite stream.
     *
     * @param name1 - Name of the first device.
     * @param name2 - Name of the second device.
     */
    exchangeVideoDevicePositions(name1: string, name2: string): void;
    /**
     * Starts the [[MediaStreamManager]] and the [[Scheduler]] to begin compositing.
     */
    start(): void;
    /**
     * Stops the [[MediaStreamManager]] and terminates the [[Scheduler]]'s WebWorker.
     */
    stop(): void;
    /**
     * Returns a boolean value representing the state of [[MediaStreamManager#running]]
     */
    isCapturing(): boolean;
    /**
     * Returns the WebAudio Context's baseLatency value.
     */
    getAudioLatency(): number;
    /**
     * Returns the video track's latency value, if available.
     */
    getVideoLatency(): number;
    /**
     * Prevents rendering of any video.
     */
    disableVideo(): void;
    /**
     * Enables rendering of all video.
     */
    enableVideo(): void;
    /**
     * Prevents rendering of any audio.
     */
    disableAudio(): void;
    /**
     * Enables rendering of all audio.
     */
    enableAudio(): void;
    /**
     * Get ideal x, y, width, height to center the source within the target
     * bounding box on the canvas.
     *
     * @param source - [[VideoDevice]] or [[ImageDevice]] that contains a CanvasImageSource
     * @param canvasWidth - canvas width
     * @param canvasHeight - canvas height
     * @returns x, y, width, height draw region within the canvas bounds
     */
    private getDrawRegion;
    /**
     * Composites all available video tracks in the mixer to the canvas.
     *
     * @private
     */
    private drawComposite;
    /**
     * Requests a frame capture from the canvas if the browser supports it.
     *
     * @private
     */
    private requestCanvasCapture;
    /**
     * Draws a black screen to the canvas.
     *
     * @private
     */
    private drawBlackScreen;
    /**
     * Looks through the provided list for the provided device and removes it from the list.
     *
     * @param name - A unique identifier to associate to the device.
     * @param list - One of the mixer's device arrays.
     * @private
     */
    private removeDevice;
    /**
     * Handles all incoming Worker thread events.
     *
     * @param event - A [[MessageEvent]] incoming from a Worker thread.
     * @private
     */
    private handleWorkerEvent;
    /**
     * Indication of whether or not we are waiting on a new video frame to be generated for a given frame rate.
     *
     * This essentially gates frames being generated at an uneven pace (e.g. Frame 1 @ 40ms, Frame 2 @ 42 ms) and
     * allows us to drop frames
     *
     * @param now - The datetime of the requested frame
     */
    private shouldMix;
}
/**
 * Creates a new HTMLVideoElement used for the user media streams.
 *
 * @private
 */
export declare function createVideoEl(): HTMLVideoElement;
/**
 * Wrapper for Number.isSafeInteger
 *
 * @param value - Any arbitrary value.
 * @private
 */
export declare function isValidNumber(value: unknown): boolean;
